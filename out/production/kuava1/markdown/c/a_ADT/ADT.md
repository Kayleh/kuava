# 线性表

### 线性表的顺序表示和实现

> 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种
> 表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为顺序
> 表（Sequential List）。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻
> 的。

假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储起始位置。
顺序表中每一个数据元素的存储位置都和线性表的起始位置相差一个和数据元素在线性表中的位序成正比的常数。由此，只要确定了存储线性表的起始位置，顺序表中任一数据元素都可随机存取

> 线性表通过顺序存储这一结构，实现随机存取这一特性。在顺序存储的线性结构中，数据元素存储的位置是连续的，这意味着我们只需要知道每一个数据元素的起始位置和一个数据元素所占的存储空间，就可以直接算出来要取出来的数据元素的地址，通过o(1)的时间复杂度就可以取出来这个数据元素。线性表通过顺序存储这一结构，实现随机存取这一特性。在顺序存储的线性结构中，数据元素存储的位置是连续的，这意味着我们只需要知道每一个数据元素的起始位置和一个数据元素所占的存储空间，就可以直接算出来要取出来的数据元素的地址，通过o(1)的时间复杂度就可以取出来这个数据元素

> 随机存取指的是当存储器中存储了线性表的数据元素,并且知道了数据元素的存储位置,就可以直接存取该数据元素,而不必遍历线性表中的所有元素。当存储器中的消息被读取或写入时，所需要的时间和这段信息所在的位置无关。

C语言中可用动态的一维数组表示线性表：

```c
//- - - - - 顺序表的存储结构- - - - -
#define
MAXSIZE 100                     //顺序表可能达到的最大长度
typedef struct
{
ElemType *elem;                      //存储空间的基地址
int length;                          //当前长度
}SqList;                                //顺序表的结构类型为SqList
```

#### 1.初始化顺序表：

```c
Status InitList(SqList &L)
{//构造一个空的顺序表L
   L.elem=new ElemType[MAXSIZE];                //为顺序表分配一个大小为MAXSIZE的数组空间
   if(!L.elem) exit(OVERFLOW);                  //存储分配失败退出
   L.length=0;                                  //空表长度为0
   return OK;
}
//动态分配线性表的存储区域可以更有效地利用系统的资源，当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间。
```

#### 2.取值

```c
Status GetElem(SqList L,int i,ElemType &e)
{
   if (i<1||i>L.length) return ERROR;          //判断i值是否合理，若不合理，返回ERROR
   e=L.elem[i-1];                            //elem[i-1]单元存储第i个数据元素
   return OK;
}
```

#### 3.查找

```c
int LocateElem(SqList L,ElemType e)
{//在顺序表L中查找值为e的数据元素，返回其序号
   for(i=0;i< L.length;i++)
     if(L.elem[i]==e) return i+1;               //查找成功，返回序号i+1
   return 0;                                    //查找失败，返回0
}
```

#### 4.插入

> 在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i=n+1，否则必须移动元素才能反映这个逻辑关系的变化。

```c
Status ListInsert(SqList &L,int i ,ElemType e)
{//在顺序表L中第i个位置插入新的元素e，i值的合法范围是1≤i≤L.length+1
   if((i<1)||(i>L.length+1)) return ERROR;                        //i值不合法
   if(L.length==MAXSIZE) return ERROR;                          //当前存储空间已满
   for(j=L.length-1;j>=i-1;j--)
     L.elem[j+1]=L.elem[j];                                     //插入位置及之后的元素后移
   L.elem[i-1]=e;                                               //将新元素e放入第i个位置
   ++L.length;                                                  //表长加1
   return OK;
}
```

#### 5.删除

```c
Status ListDelete(SqList &L,int i)
{//在顺序表L中删除第i个元素，i值的合法范围是1≤i≤L.length
   if((i<1)||(i>L.length)) return ERROR; //i值不合法
   for(j=i;j<=L.length-1;j++)
     L.elem[j-1]=L.elem[j];                      //被删除元素之后的元素前移
   --L.length;                                   //表长减1
   return OK;
}
```

线性表的缺点：

> 在做插入或删除操作时，需移动大量元素。另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，必然导致存储空间的浪费。

所有这些问题，都可以通过线性表的另一种表示方法——链式存储结构来解决.

### 线性表的链式表示和实现

### 单链表

用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。
因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点（node）。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点（ai（1≤i≤n）的存储映像）链结成一个链表，即为线性表的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。

单链表可由头指针唯一确定，在C语言中可用“结构指针”来描述：

```c
//- - - - - 单链表的存储结构- - - - -
typedef struct LNode
{
ElemType  data;//结点的数据域
struct LNode  *next;//结点的指针域
}LNode, *LinkList;//LinkList为指向结构体LNode的指针类型，用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode *定义指向单链表中任意结点的指针变量。
```

- 首元结点是指链表中存储第一个数据元素a1的结点。
- 头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，头结点的数据域中可存放该线性表的长度。
- 头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。

链表增加头结点的作用如下。 （1）便于首元结点的处理增加了头结点后，首元结点的地址保存在头结点(即其“前驱”结点)的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。
（2）便于空表和非空表的统一处理当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则当单链表为长度n为0的空表时，L指针为空（判定空表的条件可记为：L==NULL）。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。若为空表，则头结点的指针域为空（判定空表的条件可记为：L−>
next==NULL）

> 单链表是非随机存取的存储结构，要取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。因此，其基本操作的实现不同于顺序表。

#### 1.初始化

```c
Status InitList(LinkList &L)
{//构造一个空的单链表L
   L=new LNode;        //生成新结点作为头结点，用头指针L指向头结点
   L->next=NULL;     //头结点的指针域置空
   return OK;
}
```

#### 2.取值

```c
Status GetElem(LinkList L,int i,ElemType &e)
{//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
   p=L->next;j=1;                            //初始化，p指向首元结点，计数器j初值赋为1
   while(p&&j<i)                             //顺链域向后扫描，直到p为空或p指向第i个元素
   {
      p=p->next;                             //p指向下一个结点
      ++j;                                   //计数器j相应加1
   }
   if(!p||j>i)return ERROR;  //i值不合法i>n或i≤0
   e=p->data;                                //取第i个结点的数据域
   return OK;
}
```

#### 3.查找

```c
LNode *LocateElem(LinkList L，ElemType e)
{//在带头结点的单链表L中查找值为e的元素
   p=L->next;                                        //初始化，p指向首元结点
   while(p && p->data!=e)                            //顺链域向后扫描，直到p为空或p所指结点的数据域等于e
      p=p->next;                                     //p指向下一个结点
   return p;                                         //查找成功返回值为e的结点地址p，查找失败p为NULL
}
```

#### 4.插入

```c
Status ListInsert(LinkList &L,int i,ElemType e)
{//在带头结点的单链表L中第i个位置插入值为e的新结点
   p=L;j=0;
   while(p && (j<i−1))
      {p=p->next;++j;}                           //查找第i−1个结点，p指向该结点
   if(!p||j>i−1) return ERROR;                  //i>n+1或者i<1
   s=new LNode;                                 //生成新结点*s
   s->data=e;                                   //将结点*s的数据域置为e
   s->next=p->next;                             //将结点*s的指针域指向结点ai
   p->next=s;                                   //将结点*p的指针域指向结点*s
   return OK;
}
```

#### 5.删除

```c
Status ListDelete(LinkList &L,int i)
{//在带头结点的单链表L中，删除第i个元素
   p=L;j=0;
   while((p->next) && (j<i-1))                       //查找第i−1个结点，p指向该结点
     {p=p->next;++j;}
   if(!(p->next)||(j>i-1)) return ERROR;            //当i>n或i<1时，删除位置不合理
   q=p->next;                                       //临时保存被删结点的地址以备释放
   p->next=q->next;                                 //改变删除结点前驱结点的指针域
   delete q;                                        //释放删除结点的空间
   return OK;
}
```

#### 6.创建单链表

##### 前插法

> 前插法是通过将新结点逐个插入链表的头部（头结点之后）来创建链表，每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后。

```c
void CreateList_H(LinkList &L,int n)
{//逆位序输入n个元素的值，建立带表头结点的单链表L
   L=new LNode;
   L->next=NULL;                                    //先建立一个带头结点的空链表
   for(i=0;i<n;++i)
   {
     p=new LNode;                                   //生成新结点*p
     cin>>p->data;                                 //输入元素值赋给新结点*p的数据域
     p->next=L->next;L->next=p;                    //将新结点*p插入到头结点之后
   }
}
```

##### 后插法

> 后插法是通过将新结点逐个插入到链表的尾部来创建链表。同前插法一样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点。

```c
void CreateList_R(LinkList &L,int n)
{//正位序输入n个元素的值，建立带表头结点的单链表L
   L=new LNode;
   L->next=NULL;                                    //先建立一个带头结点的空链表
   r=L;                                             //尾指针r指向头结点
   for(i=0;i<n;++i)
   {
      p=new LNode;                                  //生成新结点
      cin>>p->data;                                //输入元素值赋给新结点*p的数据域
      p->next=NULL; r->next=p;                     //将新结点*p插入尾结点*r之后
      r=p;                                         //r指向新的尾结点*p
   }
}
```

### 循环链表

> 循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。

循环单链表的操作和单链表基本一致， 差别仅在于： 当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。 在单链表中，判别条件为`p!=NULL或p->next!=NULL`，而循环单链表的判别条件为`p!=L`
或`p->next!=L`。

> 将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。

### 双向链表

> 以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。为克服单链表这种单向性的缺点，可利用双向链表（Double Linked List）。

```c
// 双向链表的存储结构
typeof struce DulNode{
ElemType data; //数据域
struct DulNode *prior; //指向直接前驱
struct DulNode *next; //指向直接后继
} DulNode, *DuLinkList; 
```

和单链的循环表类似，双向链表也可以有循环表

#### 插入

插入需要修改4个指针

```c
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e) 
{//在带头结点的双向链表L中第i个位置之前插入元素e
    if (!(p = GetElem_DuL(L, i)))              //在L中确定第i个元素的位置指针p
        return ERROR;                       //p为NULL时，第i个元素不存在
    s = new DuLNode;                         //生成新结点*s
    s->data = e;                             //将结点*s数据域置为e
    s->prior = p->prior;                     //将结点*s的前驱指针指向p的前驱
    p->prior->next = s;                      //将结点*p的前驱的后继指针指向s
    s->next = p;                             //将结点*s的后继指针指向p
    p->prior = s;                            //将结点*p的前驱指针指向s
    return OK;
}
```

#### 删除

```c
Status ListDelete_DuL(DuLinkList &L,int i)
{//删除带头结点的双向链表L中的第i个元素
   if(!(p=GetElem_DuL(L,i)))            //在L中确定第i个元素的位置指针p
      return ERROR;                     //p为NULL时，第i个元素不存在
   p->prior->next=p->next;              //修改被删结点的前驱结点的后继指针，对应图2.21①
   p->next->prior=p->prior;             //修改被删结点的后继结点的前驱指针，对应图2.21②
   delete p;                            //释放被删结点的空间
   return OK;
}
```

### 顺序表和链表的比较

前面两节介绍了线性表的两种存储结构： 顺序表和链表。在实际应用中，不能笼统地说哪种存储结构更好，由于它们各有优缺点，选用哪种存储结构，则应根据具体问题作具体分析，通常从空间性能和时间性能两个方面作比较分析。

#### 空间性能的比较

- 存储空间的分配顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象；
  而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。

- 存储密度的大小链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指示元素之间逻辑关系的指针，从存储密度上来讲，这是不经济的。所谓存储密度是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比。
  存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储密度小于1。如果每个元素数据域占据的空间较小，则指针的结构性开销就占用了整个结点的大部分空间，这样存储密度较小。例如，若单链表的结点数据均为整数，指针所占用的空间和整型量相同，则单链表的存储密度
  为0.5。因此，如果不考虑顺序表中的空闲区，则顺序表的存储空间利用率为100%，而单链表的存储空间利用率仅为50%。基于此，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。

#### 时间性能的比较

- 存取元素的效率顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i，都可以在O(1)
  时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存取结构，按位置访问链表中第i个元素时，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素，时间复杂度为O(n)
  ，即取值操作的效率低。基于此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构。
- 插入和删除操作的效率对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为O(1)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为O(n)。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。

# 线性表的应用

 求解一般集合的并集问题。

```c
void MergeList(List &LA,List LB)
{//将所有在线性表LB中但不在LA中的数据元素插入到LA中
   m=ListLength(LA); n=ListLength(LB);           //求线性表的长度
   for(i=1;i<=n;i++)
   {
      GetElem(LB,i,e);                           //取LB中第i个数据元素赋给e
      if(!LocateElem(LA,e))                      //LA中不存在和e相同的数据元素
         ListInsert(LA,++m,e);                   //将e插在LA的最后
   }
}
```

有序表的合并

```c
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{//已知顺序有序表LA和LB的元素按值非递减排列
 //归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列
   LC.length=LA.length+LB.length;           //新表长度为待合并两表的长度之和
   LC.elem=new ElemType[LC.length];         //为合并后的新表分配一个数组空间
   pc=LC.elem;                              //指针pc指向新表的第一个元素
   pa=LA.elem;  pb=LB.elem;                 //指针pa和pb的初值分别指向两个表的第一个元素
   pa_last=LA.elem+LA.length-1;             //指针pa_last指向LA的最后一个元素
   pb_last=LB.elem+LB.length-1;             //指针pb_last指向LB的最后一个元素
   while((pa<=pa_last)&&(pb<=pb_last))      //LA和LB均未到达表尾
   {
     if(*pa<=*pb) *pc++=*pa++;              //依次“摘取”两表中值较小的结点插入到LC的最后
     else *pc++=*pb++;
   }
   while(pa<=pa_last)  *pc++=*pa++;         //LB已到达表尾，依次将LA的剩余元素插入LC的最后
   while(pb<=pb_last)  *pc++=*pb++;         //LA已到达表尾，依次将LB的剩余元素插入LC的最后
}
```


